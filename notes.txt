# 布尔值 True False
# and or not可以当逻辑运算符
# 空值为None，不是0
# 弱类型语言，不同类型之间可以赋值，但是后果自负，不需要申明类型
# 转义字符正常使用
# 支持Unicode
# 整数小数运算上不用考虑类型了，自己会换算，该小数小数！很好的特性
# 逻辑运算会短路
# list，我觉得是链表，允许不同类型，下标访问
listA = ['Michael','Bob',12]
listB = []
print listA[0]
print listA[-1] # 自行感受
listA.append("Sweetie")
listA.insert(0,"Paul")
listA.pop(1) # 移除并返回该元素，没有参数移除最后一个

# tuple 类似于list，但是是常量，创建后无法改变，下标访问，无法赋值
tupleA = ('Michael','Bob',12)
tupleB = (1,) # 单个元素的tuple的申明方式
# tuple如果其中一个元素是list，就可以可变！因为list可变

# if,没有结束符号，注意锁进
if flag==True:
    print("true")
elif flag==False:
    print("false")
else:
    print("else~")
print("Out of loop")

# for in
L = ['Ada','Bob','Candy']
for name in L:
    print("name is",name)
print("Out of loop")

# while
while x < N:
    x = x+1
print("Out of loop")

# break&continue 照常

# dict 字典，键值对，无序，keyo必须不可变
d = {
    'Adam':95,
    'Lisa':85
}
len(d) # length of d
if 'Adam' in d: # 判断是否在集合中
    d['Adam'] # 下标访问
# 另外一种访问方法
d.get('Adam') # 访问失败返回None
#dict和list相比占内存，查询速度快，查询时间不随尺寸增长而增长
d['NewGuy']=70 # 直接添加新元素，已有的话就替换
for a in d:
    print(a,d[a])

# set 集合，无序，不重复
set1 = set(['A','B','C']) # 遇到重复元素自动去掉
# 遍历和判断存在于dict相同
# 储存的元素必须是不变的
set1.add()
set1.remove()

# function!!
def fun1(x): # 返回多值，其实就是返回一个tuple
    return x+1,x+2
result1,result2=fun1(2)

def fun2(x,y=2): # 只有一个参数的话默认等于2
    return x+y
def fun3(*x): # 输入可变数量的参数，其实就是输入了一个tuple
    return x
# 导入包
import math
math.cos(1)

range(3) # 获得range(0,3)，相当于一个012的数组

L=[1,2,3,4]
L[0:2] #和matlab差不多诶,前闭后开
L[:] # 所有元素
L[statIndex:endIndex:2] # 每隔两个元素取出
# 切片操作也支持负数

for i in range(1,100,2): # 完成c中for形式
    print(i)

a=['A','B','C']
b=enumerate(a) # b类似[(0,'A'),(1,'B'),(2,'C')]，但是不能用索引访问
# enumerate这个函数吧对应的元素变成了索引和值组成而成的tutple
# 可以用这个函数在迭代中获取索引
# dict迭代可以得到key，要获得value的话，可以对dict.values()或dict.itervalues()迭代

dict.items() # 将dict转换为包含tuple的list

[x * x for x in range(1,11) if x%2==0] # 哇塞自行感受
[m+n for m in 'ABC' for n in '123']

'<tr><td>%s</td><td>%s</td></tr>' %(name,score) #生成字符串

a=abs # 函数作为变量使用
a(-1)

#高阶函数：吧函数作为参数接受的函数
